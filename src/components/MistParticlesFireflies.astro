---
export interface Props {
  particleCount?: number;
  color?: string;
  size?: number;
  speed?: number;
  opacity?: number;
}

const { 
  particleCount = 30,
  color = '#F5E6D3',
  size = 4,
  speed = 3,
  opacity = 0.7
} = Astro.props;
---

<div class="mist-container-fireflies" data-particle-count={particleCount} data-color={color} data-size={size} data-speed={speed} data-opacity={opacity}>
  <canvas class="mist-canvas-fireflies"></canvas>
</div>

<style lang="scss">
  @import '../styles/variables';

  .mist-container-fireflies {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    overflow: hidden;
    z-index: 1;
    
    .mist-canvas-fireflies {
      width: 100%;
      height: 100%;
      opacity: 0.8;
    }
  }
</style>

<script>
  class MistParticlesFireflies {
    constructor(container) {
      this.container = container;
      this.canvas = container.querySelector('.mist-canvas-fireflies');
      this.ctx = this.canvas.getContext('2d');
      
      this.particleCount = parseInt(container.dataset.particleCount) || 30;
      this.color = container.dataset.color || '#F5E6D3';
      this.size = parseInt(container.dataset.size) || 2;
      this.speed = parseInt(container.dataset.speed) || .25;
      this.opacity = parseFloat(container.dataset.opacity) || 0.7;
      
      this.particles = [];
      this.animationId = null;
      
      this.init();
    }
    
    init() {
      this.resize();
      this.createParticles();
      this.animate();
      
      window.addEventListener('resize', () => this.resize());
    }
    
    resize() {
      const rect = this.container.getBoundingClientRect();
      this.canvas.width = rect.width;
      this.canvas.height = rect.height;
    }
    
    createParticles() {
      this.particles = [];
      
      for (let i = 0; i < this.particleCount; i++) {
        this.particles.push({
          x: Math.random() * this.canvas.width,
          y: this.canvas.height * 0.5 + Math.random() * (this.canvas.height * 0.5),
          vx: (Math.random() - 0.5) * this.speed * 0.5,
          vy: (Math.random() - 0.5) * this.speed,
          size: Math.random() * this.size + 1,
          opacity: Math.random() * this.opacity,
          life: Math.random() * 100,
          maxLife: 100 + Math.random() * 50
        });
      }
    }
    
    updateParticle(particle) {
      particle.x += particle.vx;
      particle.y += particle.vy;
      particle.life++;
      
      // Fade in and out
      const lifeRatio = particle.life / particle.maxLife;
      if (lifeRatio < 0.1) {
        particle.opacity = (lifeRatio / 0.1) * this.opacity;
      } else if (lifeRatio > 0.9) {
        particle.opacity = (1 - (lifeRatio - 0.9) / 0.1) * this.opacity;
      } else {
        particle.opacity = this.opacity;
      }
      
      // Reset particle if it goes off screen or dies
      if (particle.y < -particle.size || 
          particle.x < -particle.size || 
          particle.x > this.canvas.width + particle.size ||
          particle.life > particle.maxLife) {
        particle.x = Math.random() * this.canvas.width;
        particle.y = this.canvas.height * 0.5 + Math.random() * (this.canvas.height * 0.5);
        particle.vx = (Math.random() - 0.5) * this.speed * 0.5;
        particle.vy = (Math.random() - 0.5) * this.speed;
        particle.life = 0;
        particle.maxLife = 100 + Math.random() * 50;
      }
      
      // Add some drift
      particle.vx += (Math.random() - 0.5) * 0.02;
      particle.vy += (Math.random() - 0.5) * 0.01;
      
      // Limit velocity
      particle.vx = Math.max(-this.speed, Math.min(this.speed, particle.vx));
      particle.vy = Math.max(-this.speed, Math.min(this.speed, particle.vy));
    }
    
    drawParticle(particle) {
      this.ctx.save();
      
      // Set particle color and opacity
      const [r, g, b] = this.hexToRgb(this.color);
      this.ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${particle.opacity})`;
      
      // Draw particle with slight blur effect
      this.ctx.shadowColor = `rgba(${r}, ${g}, ${b}, ${particle.opacity * 0.5})`;
      this.ctx.shadowBlur = particle.size * 0.5;
      
      this.ctx.beginPath();
      this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
      this.ctx.fill();
      
      this.ctx.restore();
    }
    
    hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? [
        parseInt(result[1], 16),
        parseInt(result[2], 16),
        parseInt(result[3], 16)
      ] : [245, 230, 211];
    }
    
    animate() {
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      
      this.particles.forEach(particle => {
        this.updateParticle(particle);
        this.drawParticle(particle);
      });
      
      this.animationId = requestAnimationFrame(() => this.animate());
    }
    
    destroy() {
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
      }
      window.removeEventListener('resize', () => this.resize());
    }
  }
  
  // Initialize all mist particle containers with delay
  document.addEventListener('DOMContentLoaded', () => {
    const containers = document.querySelectorAll('.mist-container-fireflies');
    containers.forEach(container => {
      setTimeout(() => {
        new MistParticlesFireflies(container);
      }, 3000);
    });
  });
  
  // Handle visibility changes to optimize performance
  document.addEventListener('visibilitychange', () => {
    const containers = document.querySelectorAll('.mist-container-fireflies');
    containers.forEach(container => {
      if (document.hidden) {
        container.mistParticlesFireflies?.destroy();
      } else {
        container.mistParticlesFireflies = new MistParticlesFireflies(container);
      }
    });
  });
</script>