---
import BaseLayout from "../layouts/BaseLayout.astro";
import LiquidTransition from "../components/LiquidTransition.astro";
import BeerCard from "../components/BeerCard.astro";
import MistParticlesBeer from "../components/MistParticlesBeer.astro";
import MistParticlesFireflies from "../components/MistParticlesFireflies.astro";

const beers = [
  {
    name: "Dark Lodge IPA",
    type: "India Pale Ale",
    abv: 6.8,
    ibu: 65,
    description:
      "A secret blend of citrus and pine with a dark, smoky finish that lingers like whispers in the night.",
    color: "#D2691E",
    available: true,
  },
  {
    name: "Midnight Porter",
    type: "Robust Porter",
    abv: 5.4,
    ibu: 35,
    description:
      "Rich chocolate and coffee notes with a smooth texture. Perfect for contemplating life's mysteries.",
    color: "#2F1B14",
    available: true,
  },
  {
    name: "Copper Log Lager",
    type: "Vienna Lager",
    abv: 4.8,
    ibu: 22,
    description:
      "Crisp and clean with a subtle malty sweetness and a hint of the forest floor after rain.",
    color: "#B87333",
    available: true,
  },
  {
    name: "Red Room Ale",
    type: "American Red Ale",
    abv: 5.9,
    ibu: 40,
    description:
      "A bold red ale with caramel backbone and curious floral notes that dance on the palate.",
    color: "#A0522D",
    available: false,
  },
  {
    name: "Twin Peaks Wheat",
    type: "Hefeweizen",
    abv: 4.2,
    ibu: 15,
    description:
      "Light and cloudy with notes of banana and clove, as enigmatic as morning mist on the mountains.",
    color: "#F4A460",
    available: true,
  },
  {
    name: "Lodge Stout",
    type: "Imperial Stout",
    abv: 8.2,
    ibu: 55,
    description:
      "Deep, dark, and complex with notes of vanilla, oak, and whispers of ancient secrets.",
    color: "#1C1C1C",
    available: true,
  },
];

const events = [
  {
    date: "July 4",
    title: "Independence Day Celebration",
    description: "Celebrating with an explosive brew that proudly stands on its own",
  },
  {
    date: "July 15",
    title: "Mystery Beer Release",
    description: "Unveiling our latest creation - a beer shrouded in mystery",
  },
  {
    date: "July 22",
    title: "Trivia Night",
    description: "Test your knowledge of mysteries, both solved and unsolved",
  },
  {
    date: "July 29",
    title: "Live Jazz Evening",
    description:
      "Sultry sounds to accompany your evening libations with friends",
  },
];
---

<BaseLayout
  title="Black Lodge Brews - Premium Craft Brewery"
  description="Enter the mysterious world of Black Lodge Brews, where every sip tells a story and every brew holds secrets waiting to be discovered."
>

  <LiquidTransition direction="up" duration={0.8} color="#FFA000" />

  <!-- Hero Section -->
  <section class="hero section filling-section" id="lodge">
    <div class="hero-content">
      <div class="hero-text">
        <h1 class="hero-title">Black<br /> Lodge<br /> Brews</h1>
        <p class="hero-subtitle">Histories poured<br>into every glass</p>
      </div>
    </div>
    <div class="beer-level-container">
      <div class="beer-level">
        <div class="beer-liquid"></div>
        <div class="beer-foam"></div>
      </div>
    </div>
    <MistParticlesBeer
      particleCount={40}
      color="#FFFFFF"
      size={3}
      speed={1.5}
      opacity={0.5}
    />
  </section>

  <!-- Tap List Section -->
  <section id="taps" class="section taps-section">
    <div class="container">
      <h2 class="section-title">Our Woodsy Taps</h2>
      <p class="section-subtitle">
        Each brew tells a story, each sip reveals a secret
      </p>

      <div class="beers-grid">
        {beers.map((beer) => <BeerCard {...beer} />)}
      </div>
    </div>
  </section>

  <!-- Our Story Section -->
  <section id="story" class="section story-section">
    <div class="parallax-bg story-bg" data-speed="0.5"></div>
    <div class="container">
      <div class="story-content">
        <div class="story-text">
          <h2>The Legend of Black Lodge</h2>
          <p>
            Deep in the heart of the Pacific Northwest, where ancient forests
            whisper secrets and mist dances through towering pines, lies the
            enigmatic Black Lodge Brewery. Founded in 2023 by a group of
            passionate brewers who believe that the best ales are born from
            mystery and crafted with intention.
          </p>

          <p>
            Our brewing process is as much art as it is science. We source our
            ingredients from local farms that have been tended by generations of
            families who understand the land's perplexities. Each batch is carefully
            crafted in small quantities, ensuring that every glass carries the
            essence of our mystic heritage.
          </p>

          <p>
            The lodge itself stands as a testament to craftsmanship.
            Built from reclaimed timber and stone, it houses our
            state-of-the-art brewing equipment alongside relics and curiosities
            collected from around the world. Every corner tells a story, every
            shadow holds a secret.
          </p>
        </div>
      </div>
    </div>
    <MistParticlesFireflies
      particleCount={10}
      color="#FFA000"
      size={1}
      speed={0.05}
      opacity={0.3}
    />
  </section>

  <!-- Taproom Section -->
  <section id="taproom" class="section taproom-section">
    <div class="container">
      <h2 class="section-title">The Taproom Experience</h2>
      <p class="section-subtitle">
        Step into a world where every detail matters
      </p>

      <div class="taproom-content">
        <div class="taproom-description">
          <h3>Immerse Yourself</h3>
          <div class="taproom-features">
              <div class="feature blob-content">
                <h4>üç∫ Fresh Pours</h4>
                <p>
                  All our beers are served at the perfect temperature from our
                  custom tap system
                </p>
                <!-- <canvas class="ripple-canvas"></canvas> -->
              </div>
              <div class="feature blob-content">
                <h4>üéµ Live Music</h4>
                <p>
                  Regular performances featuring local jazz groups, folk singers,
                  and ambient artists
                </p>
                <!-- <canvas class="ripple-canvas"></canvas> -->
              </div>
              <div class="feature blob-content">
                <h4>ü•® Artisan Bites</h4>
                <p>
                  Carefully selected food pairings, sweet and savory, that
                  complement our unique brews
                </p>
                <!-- <canvas class="ripple-canvas"></canvas> -->
              </div>
            </div>
        </div>

        <div class="events-calendar">
          <h3>Upcoming Events</h3>
          <div class="events-list">
              {
                events.map((event, idx) => (
                  <div class="event-item">
                    <div class={`event-date watery-blob-container blob-${idx}`}><span>{event.date}</span></div>
                    <div class="event-details">
                      <h4>{event.title}</h4>
                      <p>{event.description}</p>
                    </div>
                  </div>
                ))
              }
            </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Contact Section -->
  <section id="contact" class="section contact-section">
    <div class="parallax-bg contact-bg" data-speed="0.3"></div>
    <div class="container">
      <h2 class="section-title">Find Your Way to the Lodge</h2>

      <div class="contact-content">
        <div class="contact-info">
          <div class="contact-item">
            <h3>
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 24 24"
                fill="#FFD54F"
                class="contact-icon"
                ><path
                  fill-rule="evenodd"
                  d="m11.54 22.351.07.04.028.016a.76.76 0 0 0 .723 0l.028-.015.071-.041a16.975 16.975 0 0 0 1.144-.742 19.58 19.58 0 0 0 2.683-2.282c1.944-1.99 3.963-4.98 3.963-8.827a8.25 8.25 0 0 0-16.5 0c0 3.846 2.02 6.837 3.963 8.827a19.58 19.58 0 0 0 2.682 2.282 16.975 16.975 0 0 0 1.145.742ZM12 13.5a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z"
                  clip-rule="evenodd"></path></svg
              > Location
            </h3>
            <p>123 Brewery Lane<br />Portland, OR 97210</p>
          </div>

          <div class="contact-item">
            <h3>
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 24 24"
                fill="#FFD54F"
                class="contact-icon"
                ><path
                  d="M10.5 18.75a.75.75 0 0 0 0 1.5h3a.75.75 0 0 0 0-1.5h-3Z"
                ></path><path
                  fill-rule="evenodd"
                  d="M8.625.75A3.375 3.375 0 0 0 5.25 4.125v15.75a3.375 3.375 0 0 0 3.375 3.375h6.75a3.375 3.375 0 0 0 3.375-3.375V4.125A3.375 3.375 0 0 0 15.375.75h-6.75ZM7.5 4.125C7.5 3.504 8.004 3 8.625 3h6.75c.621 0 1.125.504 1.125 1.125v15.75c0 .621-.504 1.125-1.125 1.125h-6.75A1.125 1.125 0 0 1 7.5 19.875V4.125Z"
                  clip-rule="evenodd"></path></svg
              > Phone
            </h3>
            <p>(503) 555-BREW</p>
          </div>

          <div class="contact-item">
            <h3>
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 24 24"
                fill="#FFD54F"
                class="contact-icon"
                ><path
                  fill-rule="evenodd"
                  d="M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25ZM12.75 6a.75.75 0 0 0-1.5 0v6c0 .414.336.75.75.75h4.5a.75.75 0 0 0 0-1.5h-3.75V6Z"
                  clip-rule="evenodd"></path></svg
              > Hours
            </h3>
            <p>
              Monday - Thursday: 4pm - 10pm<br />
              Friday - Saturday: 2pm - 12am<br />
              Sunday: 2pm - 9pm
            </p>
          </div>
        </div>

        <div class="map-container">
          <iframe
            src="https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d11179.794472859286!2d-122.69833!3d45.52306!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x549509fc2302c4ad%3A0x23b6b67b7be6d6d1!2sPearl%20District%2C%20Portland%2C%20OR!5e0!3m2!1sen!2sus!4v1700000000000!5m2!1sen!2sus"
            width="70%"
            height="300"
            style="border:0; border-radius: 16px; margin-top: 50px;"
            allowfullscreen=""
            loading="lazy"
            referrerpolicy="no-referrer-when-downgrade"
            title="Black Lodge Brews Location - Portland, OR"
          >
          </iframe>
        </div>
      </div>
    </div>
  </section>
</BaseLayout>

<style lang="scss">
  @import "../styles/global.scss";
  @import "../styles/home-page";
  
  // Custom particle canvas sizing - extend both up and down for maximum coverage
  .hero .mist-container-beer {
    height: 150%;
    top: -25%;
  }
</style>

<script>
  // GSAP ScrollTrigger Parallax Implementation
  import { gsap } from 'gsap';
  import { ScrollTrigger } from 'gsap/ScrollTrigger';

  // Register ScrollTrigger plugin
  gsap.registerPlugin(ScrollTrigger);

  // Card animation on scroll
  class CardAnimator {
    private animatedCards: Set<Element>;
    constructor() {
      this.animatedCards = new Set();
      this.init();
    }

    init() {
      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting && !this.animatedCards.has(entry.target)) {
              // Add staggered delay for multiple cards
              const parent = entry.target.parentElement;
              const delay = parent
                ? Array.from(parent.children).indexOf(entry.target) * 150
                : 0;

              setTimeout(() => {
                entry.target.classList.add("fade-in-up");
                this.animatedCards.add(entry.target);
              }, delay);
            }
          });
        },
        {
          threshold: 0.2,
          rootMargin: "0px 0px -30px 0px",
        }
      );

      // Observe all feature and event cards
      document.querySelectorAll(".feature, .event-item").forEach((card) => {
        observer.observe(card);
      });
    }
  }


  // Three.js WebGL Ripple Effect for Feature Cards
  class RippleEffect {
    private card: HTMLElement;
    private canvas: HTMLCanvasElement;
    private scene: any;
    private camera: any;
    private renderer: any;
    private planeMesh: any;
    private rippleMaterial: any;
    private isRippleActive: boolean;
    private rippleStartTime: number;
    private rippleDuration: number;
    private animationFrameId: number | null;

    constructor(cardElement: HTMLElement) {
      this.card = cardElement;
      this.canvas = cardElement.querySelector('.ripple-canvas') as HTMLCanvasElement;
      this.scene = null;
      this.camera = null;
      this.renderer = null;
      this.planeMesh = null;
      this.rippleMaterial = null;
      this.isRippleActive = false;
      this.rippleStartTime = 0;
      this.rippleDuration = 1000;
      this.animationFrameId = null;
      
      console.log('RippleEffect constructor called for card:', this.card);
      console.log('Canvas found:', this.canvas);
      
      this.init();
    }
    
    init() {
      // Libraries should be available since they're loaded in the head
      console.log('Initializing ripple effect...');
      console.log('THREE available:', typeof (window as any).THREE);
      console.log('html2canvas available:', typeof (window as any).html2canvas);
      
      if (typeof (window as any).THREE !== 'undefined' && typeof (window as any).html2canvas !== 'undefined') {
        this.captureCardContent();
        this.setupEventListeners();
      } else {
        console.error('Libraries not loaded yet, trying again in 500ms');
        setTimeout(() => this.init(), 500);
      }
    }
    
    captureCardContent() {
      console.log('Capturing card content...');
      (window as any).html2canvas(this.card, {
        useCORS: true,
        backgroundColor: null,
        scale: 2
      }).then((canvas: HTMLCanvasElement) => {
        console.log('html2canvas succeeded, creating texture...');
        const THREE = (window as any).THREE;
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        this.initThreeJS(texture);
      }).catch((error: any) => {
        console.warn('html2canvas failed, using fallback:', error);
        const THREE = (window as any).THREE;
        this.initThreeJS(new THREE.Color(0x3e2723));
      });
    }
    
    initThreeJS(texture: any) {
      console.log('Initializing Three.js with texture:', texture);
      const THREE = (window as any).THREE;
      const cardWidth = this.card.offsetWidth;
      const cardHeight = this.card.offsetHeight;
      const cardAspect = cardWidth / cardHeight;
      console.log('Card dimensions:', cardWidth, 'x', cardHeight, 'aspect:', cardAspect);
      
      this.canvas.width = cardWidth;
      this.canvas.height = cardHeight;
      
      // Scene setup
      this.scene = new THREE.Scene();
      this.camera = new THREE.OrthographicCamera(
        cardWidth / -2, cardWidth / 2,
        cardHeight / 2, cardHeight / -2,
        1, 1000
      );
      this.camera.position.z = 10;
      
      // Renderer setup
      this.renderer = new THREE.WebGLRenderer({
        canvas: this.canvas,
        alpha: true,
        antialias: true
      });
      this.renderer.setPixelRatio(window.devicePixelRatio);
      this.renderer.setSize(cardWidth, cardHeight);
      this.renderer.setClearColor(0x000000, 0);
      
      // Geometry and material
      const geometry = new THREE.PlaneGeometry(cardWidth, cardHeight);
      
      const vertexShader = `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `;
      
      const fragmentShader = `
        uniform float u_time;
        uniform vec2 u_center;
        uniform sampler2D u_texture;
        uniform float u_aspect;
        varying vec2 vUv;
        
        void main() {
          vec2 uv = vUv;
          vec2 p = uv - u_center;
          p.x *= u_aspect;
          
          float dist = length(p);
          float maxRippleRadius = 1.0;
          float rippleEdgeSharpness = 0.06;
          float rippleAmplitude = 0.12;
          
          float currentRadius = u_time * maxRippleRadius;
          float strength = smoothstep(currentRadius - rippleEdgeSharpness, currentRadius, dist) -
                          smoothstep(currentRadius, currentRadius + rippleEdgeSharpness, dist);
          
          float fadeOut = 1.0 - u_time;
          float distortion = strength * rippleAmplitude * fadeOut;
          
          vec2 displacedUV = uv + normalize(p) * distortion;
          gl_FragColor = texture2D(u_texture, displacedUV);
        }
      `;
      
      this.rippleMaterial = new THREE.ShaderMaterial({
        uniforms: {
          u_time: { value: 0.0 },
          u_center: { value: new THREE.Vector2(0.5, 0.5) },
          u_texture: { value: texture },
          u_aspect: { value: cardAspect }
        },
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        transparent: true
      });
      
      this.planeMesh = new THREE.Mesh(geometry, this.rippleMaterial);
      this.scene.add(this.planeMesh);
      
      this.renderer.render(this.scene, this.camera);
    }
    
    setupEventListeners() {
      console.log('Setting up event listeners for card:', this.card);
      this.card.addEventListener('click', (event: MouseEvent) => {
        console.log('Card clicked!', event);
        if (!this.isRippleActive && this.rippleMaterial) {
          console.log('Triggering ripple...');
          this.triggerRipple(event);
        } else {
          console.log('Ripple not triggered - isRippleActive:', this.isRippleActive, 'rippleMaterial:', this.rippleMaterial);
        }
      });
    }
    
    triggerRipple(event: MouseEvent) {
      this.isRippleActive = true;
      this.rippleStartTime = performance.now();
      
      const rect = this.card.getBoundingClientRect();
      const x = (event.clientX - rect.left) / rect.width;
      const y = 1.0 - (event.clientY - rect.top) / rect.height;
      
      const clampedX = Math.max(0, Math.min(1, x));
      const clampedY = Math.max(0, Math.min(1, y));
      
      this.rippleMaterial.uniforms.u_center.value.set(clampedX, clampedY);
      this.canvas.style.opacity = '1';
      
      this.animate();
    }
    
    animate() {
      if (this.isRippleActive) {
        const currentTime = performance.now();
        let elapsedTime = (currentTime - this.rippleStartTime) / this.rippleDuration;
        
        if (elapsedTime < 1.0) {
          this.rippleMaterial.uniforms.u_time.value = elapsedTime;
          this.renderer.render(this.scene, this.camera);
          this.animationFrameId = requestAnimationFrame(() => this.animate());
        } else {
          this.isRippleActive = false;
          this.canvas.style.opacity = '0';
          this.rippleMaterial.uniforms.u_time.value = 0.0;
        }
      }
    }
  }

  // Initialize when DOM is loaded
  document.addEventListener("DOMContentLoaded", () => {
    console.log('DOM loaded, initializing components...');
    new CardAnimator();
    
    // Initialize ripple effects for feature cards
    const rippleCards = document.querySelectorAll('.ripple-card');
    console.log('Found', rippleCards.length, 'ripple cards');
    
    rippleCards.forEach(card => {
      console.log('Initializing ripple effect for card:', card);
      new RippleEffect(card as HTMLElement);
    });
  });

  // Re-initialize on Astro page transitions
  document.addEventListener("astro:page-load", () => {
    new CardAnimator();
    
    // Initialize ripple effects for feature cards
    document.querySelectorAll('.ripple-card').forEach(card => {
      new RippleEffect(card as HTMLElement);
    });
  });

  // Beer level filling animation
  class SectionFillAnimation {
    private fillingSection: HTMLElement | null;
    private isAnimating: boolean;

    constructor() {
      this.fillingSection = document.querySelector(".filling-section");
      this.isAnimating = false;

      if (this.fillingSection) {
        // Start filling animation after 2 seconds
        setTimeout(() => {
          this.startFilling();
        }, 2000);
      }
    }

    startFilling() {
      if (this.isAnimating) return;

      this.isAnimating = true;
      this.fillingSection!.classList.add("filling");

      // Add filled class after animation completes
      setTimeout(() => {
        this.fillingSection!.classList.add("filled");
      }, 4000);
    }
  }

  // Initialize section fill animation
  new SectionFillAnimation();

  // Blob content hover removal functionality
  class BlobContentRemover {
    constructor() {
      this.init();
    }

    init() {
      // Find all feature divs with blob-content class
      const featureElements = document.querySelectorAll('.feature.blob-content');
      
      featureElements.forEach(element => {
        // Desktop: mouseenter for hover
        element.addEventListener('mouseenter', () => {
          element.classList.remove('blob-content');
        });
        
        // Mobile: touchstart for tap/press
        element.addEventListener('touchstart', () => {
          element.classList.remove('blob-content');
        }, { passive: true });
        
        // Alternative: click event (works on both desktop and mobile)
        element.addEventListener('click', () => {
          element.classList.remove('blob-content');
        });
      });
    }
  }

  // Initialize blob content remover
  new BlobContentRemover();

  // Event-date blob remover functionality
  class EventDateBlobRemover {
    constructor() {
      this.init();
    }

    init() {
      // Find all event-date elements
      const eventDateElements = document.querySelectorAll('.event-date');
      
      eventDateElements.forEach(element => {
        // Desktop: mouseenter for hover
        element.addEventListener('mouseenter', () => {
          this.removeBlobClasses(element);
        });
        
        // Mobile: touchstart for tap/press
        element.addEventListener('touchstart', () => {
          this.removeBlobClasses(element);
        }, { passive: true });
        
        // Alternative: click event (works on both desktop and mobile)
        element.addEventListener('click', () => {
          this.removeBlobClasses(element);
        });
      });
    }

    removeBlobClasses(element) {
      // Remove watery-blob-container class
      element.classList.remove('watery-blob-container');
      
      // Remove any blob-* classes (blob-0, blob-1, blob-2, blob-3, etc.)
      const classList = Array.from(element.classList);
      classList.forEach(className => {
        if (className.startsWith('blob-')) {
          element.classList.remove(className);
        }
      });
    }
  }

  // Initialize event-date blob remover
  new EventDateBlobRemover();

  // Professional parallax implementation
  class GSAPParallaxController {
    constructor() {
      this.initParallax();
    }

    initParallax() {
      // Wait for DOM to be fully loaded
      gsap.set('.parallax-bg', { transformOrigin: 'center center' });

      // Story section parallax
      gsap.to('.story-bg', {
        y: '-30%',
        ease: 'none',
        scrollTrigger: {
          trigger: '.story-section',
          start: 'top bottom',
          end: 'bottom top',
          scrub: 1, // Smooth scrubbing
          invalidateOnRefresh: true,
        }
      });

      // Contact section parallax with different speed
      gsap.to('.contact-bg', {
        y: '-20%',
        ease: 'none',
        scrollTrigger: {
          trigger: '.contact-section',
          start: 'top bottom',
          end: 'bottom top',
          scrub: 1.2, // Slightly different scrub for variation
          invalidateOnRefresh: true,
        }
      });

      // Refresh ScrollTrigger on window resize
      window.addEventListener('resize', () => {
        ScrollTrigger.refresh();
      });
    }
  }

  // Initialize when DOM is loaded
  document.addEventListener('DOMContentLoaded', () => {
    new GSAPParallaxController();
  });

  // Re-initialize on Astro page transitions
  document.addEventListener('astro:page-load', () => {
    new GSAPParallaxController();
    new BlobContentRemover();
    new EventDateBlobRemover();
  });

</script>
